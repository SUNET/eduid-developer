#!/usr/bin/env python
"""
Translate registrator output to vulcand configuration.

The registrator watches the docker socket for startup/shutdown events,
and inserts keys into etcd for every port (in the eduid-developer setting,
this is for every "internal" port on the container - we don't expose the
ports of the backend services.

Vulcand is a reverse proxy that reads it's configuration from etcd and updates
backend/frontend configuration dynamically. The vulcand syntax doesn't match
the registrator output syntax though, so this little translator service needs
to be running. It will read everything registrator writes into etcd and convert
it to vulcand syntax, also in etcd.

Author : Fredrik Thulin <fredrik@thulin.net>
"""

import sys
import etcd
import time
import json
import logging


APPS = ['signup', 'dashboard', 'idp', 'actions', 'landing-page']
MAP = {'/services/eduid-signup/': '/vulcand/backends/signup/servers/',
       '/services/eduid-dashboard/': '/vulcand/backends/dashboard/servers/',
       '/services/eduid-idp/': '/vulcand/backends/idp/servers/',
       '/services/eduid-actions/': '/vulcand/backends/actions/servers/',
       '/services/html/': '/vulcand/backends/landing-page/servers/',
       }


def configure_vulcand(client, logger):
    """
    Set up vulcand configuration. Since etcd runs without persistent storage
    in the eduid-developer setting, this needs to be done at every startup.

    :param client: etcd client
    :param logger: logging logger

    :type client: etcd.Client
    :type logger: logging.logger
    :return:
    """
    for app in APPS:
        app_fe = {'Type': 'http',
                  'BackendId': app,
                  'Route': 'Path(`/{!s}/`)'.format(app),
                  }
        app_be = {'Type': 'http'}
        client.write('/vulcand/frontends/{!s}/frontend'.format(app), json.dumps(app_fe))
        client.write('/vulcand/backends/{!s}/backend'.format(app), json.dumps(app_be))
        logger.info('Configured frontend+backend for app {!r}'.format(app))


def loop(client, logger):
    """
    Wait for etcd events in the /services subtree. Look for a prefix-match in MAP
    and translate the data from registrator format to vulcand format. Finally,
    store the data in the /vulcand part of the tree.

    :param client: etcd client
    :param logger: logging logger

    :type client: etcd.Client
    :type logger: logging.logger
    :return:
    """
    logger.info('Waiting for changes under /services in etcd')
    while True:
        try:
            this = client.read('/services', recursive=True, wait=True)

            if not isinstance(this, etcd.EtcdResult):
                continue

            found = False
            for (map_prefix, map_value) in MAP.items():
                if this.key.startswith(map_prefix):
                    found = True
                    logger.info('{!s} now at {!s}'.format(this.key, this.value))

                    docker_info = this.key.split('/')[-1]
                    update_key = map_value + docker_info

                    if this.value is not None:
                        data = {'URL': 'http://{!s}'.format(this.value)}

                        client.write(update_key, json.dumps(data), ttl=this.ttl)
                        logger.info('Updated {!s} (TTL {!s}, at {!s})'.format(update_key, this.ttl, this.value))
                    else:
                        logger.info('Removing {!s}'.format(update_key))
                        client.delete(update_key)
            if not found:
                logger.debug('Ignored: {!s} -> {!s}'.format(this.key, this.value))

        except etcd.EtcdException:
            pass
        finally:
            time.sleep(1)


def main():
    logging.basicConfig(level = logging.INFO, stream = sys.stderr,
                        format='%(asctime)s %(name)s %(threadName)s: %(levelname)s %(message)s')
    logger = logging.getLogger('reg2vulcan')
    client = etcd.Client(host='172.17.42.1',
                         port=4001,
                         allow_reconnect=True)
    logger.info('Connected to etcd: {!s}'.format(client))

    configure_vulcand(client, logger)
    return loop(client, logger)


if __name__ == '__main__':
    try:
        if main():
            sys.exit(0)
        sys.exit(1)
    except KeyboardInterrupt:
        pass
